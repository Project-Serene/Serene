Index: SereneCompiler/SereneCompiler.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n\r\n    C++ Headers\r\n\r\n */\r\n\r\n#include <iostream>\r\n#include <locale>\r\n#include <optional>\r\n#include <string>\r\n#include <functional>\r\n\r\n\r\n/*\r\n\r\n    Luau Analysis Headers\r\n\r\n*/\r\n\r\n#include \"Luau/ModuleResolver.h\"\r\n#include \"Luau/TypeInfer.h\"\r\n#include \"Luau/BuiltinDefinitions.h\"\r\n#include \"Luau/Frontend.h\"\r\n#include \"Luau/TypeAttach.h\"\r\n#include \"Luau/Transpiler.h\"\r\n\r\n#include \"FileUtils.h\"\r\n#include \"Flags.h\"\r\n\r\nLUAU_FASTFLAG(DebugLuauTimeTracing)\r\nLUAU_FASTFLAG(LuauTypeMismatchModuleNameResolution)\r\n\r\n\r\n/*\r\n\r\n    Luau Compiler Headers\r\n\r\n*/\r\n\r\n#include \"Luau/Compiler.h\"\r\n#include \"Luau/BytecodeBuilder.h\"\r\n#include \"Luau/JsonEncoder.h\"\r\n\r\n\r\n#ifdef _WIN32\r\n\r\n#include <io.h>\r\n#include <fcntl.h>\r\n\r\n#endif\r\n\r\n/*\r\n \r\n    Compile Options\r\n \r\n */\r\n\r\nstruct GlobalOptions {\r\n    int optimizationLevel = 1;\r\n    int debugLevel = 1;\r\n} globalOptions;\r\n\r\nstatic Luau::CompileOptions copts() {\r\n    Luau::CompileOptions result = {};\r\n    result.optimizationLevel = globalOptions.optimizationLevel;\r\n    result.debugLevel = globalOptions.debugLevel;\r\n    result.coverageLevel = 0;\r\n    return result;\r\n}\r\n\r\n/*\r\n\r\n    Error Reporting\r\n\r\n */\r\n\r\nenum class ReportFormat {\r\n    Default,\r\n    Luacheck,\r\n    Gnu,\r\n};\r\n\r\n\r\nstatic void report(const char *name, const Luau::Location &location, const char *type, const char *message) {\r\n    fprintf(stderr, \"%s(%d,%d): %s: %s\\n\", name, location.begin.line + 1, location.begin.column + 1, type, message);\r\n}\r\n\r\nstatic void\r\nreport(ReportFormat format, const char *name, const Luau::Location &loc, const char *type, const char *message) {\r\n    switch (format) {\r\n        case ReportFormat::Default:\r\n            fprintf(stderr, \"%s(%d,%d): %s: %s\\n\", name, loc.begin.line + 1, loc.begin.column + 1, type, message);\r\n            break;\r\n\r\n        case ReportFormat::Luacheck: {\r\n            // Note: luacheck's end column is inclusive but our end column is exclusive\r\n            // In addition, luacheck doesn't support multi-line messages, so if the error is multiline we'll fake end column as 100 and hope for the best\r\n            int columnEnd = (loc.begin.line == loc.end.line) ? loc.end.column : 100;\r\n\r\n            // Use stdout to match luacheck behavior\r\n            fprintf(stdout, \"%s:%d:%d-%d: (W0) %s: %s\\n\", name, loc.begin.line + 1, loc.begin.column + 1, columnEnd,\r\n                    type, message);\r\n            break;\r\n        }\r\n\r\n        case ReportFormat::Gnu:\r\n            // Note: GNU end column is inclusive but our end column is exclusive\r\n            fprintf(stderr, \"%s:%d.%d-%d.%d: %s: %s\\n\", name, loc.begin.line + 1, loc.begin.column + 1,\r\n                    loc.end.line + 1, loc.end.column, type, message);\r\n            break;\r\n    }\r\n}\r\n\r\nstatic void reportError(const Luau::Frontend &frontend, ReportFormat format, const Luau::TypeError &error) {\r\n    std::string humanReadableName = frontend.fileResolver->getHumanReadableModuleName(error.moduleName);\r\n\r\n    if (const auto *syntaxError = Luau::get_if<Luau::SyntaxError>(&error.data))\r\n        report(format, humanReadableName.c_str(), error.location, \"SyntaxError\", syntaxError->message.c_str());\r\n    else if (FFlag::LuauTypeMismatchModuleNameResolution)\r\n        report(format, humanReadableName.c_str(), error.location, \"TypeError\",\r\n               Luau::toString(error, Luau::TypeErrorToStringOptions{frontend.fileResolver}).c_str());\r\n    else\r\n        report(format, humanReadableName.c_str(), error.location, \"TypeError\", Luau::toString(error).c_str());\r\n}\r\n\r\n\r\nstatic void reportError(const char *name, const Luau::ParseError &error) {\r\n    report(name, error.getLocation(), \"SyntaxError\", error.what());\r\n}\r\n\r\nstatic void reportError(const char *name, const Luau::CompileError &error) {\r\n    report(name, error.getLocation(), \"CompileError\", error.what());\r\n}\r\n\r\nstatic void reportWarning(ReportFormat format, const char *name, const Luau::LintWarning &warning) {\r\n    report(format, name, warning.location, Luau::LintWarning::getName(warning.code), warning.text.c_str());\r\n}\r\n\r\n/*\r\n\r\n    Analysing Lua Files\r\n\r\n */\r\n\r\nstatic bool analyzeFile(Luau::Frontend &frontend, const char *name, ReportFormat format, bool annotate) {\r\n    Luau::CheckResult cr;\r\n\r\n    if (frontend.isDirty(name))\r\n        cr = frontend.check(name);\r\n\r\n    if (!frontend.getSourceModule(name)) {\r\n        fprintf(stderr, \"Error opening %s\\n\", name);\r\n        return false;\r\n    }\r\n\r\n    for (auto &error: cr.errors)\r\n        reportError(frontend, format, error);\r\n\r\n    Luau::LintResult lr = frontend.lint(name);\r\n\r\n    std::string humanReadableName = frontend.fileResolver->getHumanReadableModuleName(name);\r\n    for (auto &error: lr.errors)\r\n        reportWarning(format, humanReadableName.c_str(), error);\r\n    for (auto &warning: lr.warnings)\r\n        reportWarning(format, humanReadableName.c_str(), warning);\r\n\r\n    if (annotate) {\r\n        Luau::SourceModule *sm = frontend.getSourceModule(name);\r\n        Luau::ModulePtr m = frontend.moduleResolver.getModule(name);\r\n\r\n        Luau::attachTypeData(*sm, *m);\r\n\r\n        std::string annotated = Luau::transpileWithTypes(*sm->root);\r\n\r\n        printf(\"%s\", annotated.c_str());\r\n    }\r\n\r\n    return cr.errors.empty() && lr.errors.empty();\r\n}\r\n\r\n/*\r\n\r\n    File resolver\r\n\r\n */\r\n\r\n\r\nstruct CliFileResolver : Luau::FileResolver {\r\n    std::optional<Luau::SourceCode> readSource(const Luau::ModuleName &name) override {\r\n        Luau::SourceCode::Type sourceType;\r\n        std::optional<std::string> source = readFile(name);\r\n\r\n        sourceType = Luau::SourceCode::Module;\r\n\r\n        if (!source)\r\n            return std::nullopt;\r\n\r\n        return Luau::SourceCode{*source, sourceType};\r\n    }\r\n\r\n    std::optional<Luau::ModuleInfo> resolveModule(const Luau::ModuleInfo *context, Luau::AstExpr *node) override {\r\n        if (auto *expr = node->as<Luau::AstExprConstantString>()) {\r\n            Luau::ModuleName name = std::string(expr->value.data, expr->value.size) + \".luau\";\r\n            if (!readFile(name)) {\r\n                // fall back to .lua if a module with .luau doesn't exist\r\n                name = std::string(expr->value.data, expr->value.size) + \".lua\";\r\n            }\r\n\r\n            return {{name}};\r\n        }\r\n\r\n        return std::nullopt;\r\n    }\r\n\r\n    [[nodiscard]] std::string getHumanReadableModuleName(const Luau::ModuleName &name) const override {\r\n        return name;\r\n    }\r\n};\r\n\r\n/*\r\n\r\n    Config Resolver\r\n\r\n */\r\n\r\nstruct CliConfigResolver : Luau::ConfigResolver {\r\n    Luau::Config defaultConfig;\r\n\r\n    mutable std::unordered_map<std::string, Luau::Config> configCache;\r\n    mutable std::vector<std::pair<std::string, std::string>> configErrors;\r\n\r\n    explicit CliConfigResolver(Luau::Mode mode) {\r\n        defaultConfig.mode = mode;\r\n    }\r\n\r\n    const Luau::Config &getConfig(const Luau::ModuleName &name) const override {\r\n        std::optional<std::string> path = getParentPath(name);\r\n        if (!path)\r\n            return defaultConfig;\r\n\r\n        return readConfigRec(*path);\r\n    }\r\n\r\n    const Luau::Config &readConfigRec(const std::string &path) const {\r\n        auto it = configCache.find(path);\r\n        if (it != configCache.end())\r\n            return it->second;\r\n\r\n        std::optional<std::string> parent = getParentPath(path);\r\n        Luau::Config result = parent ? readConfigRec(*parent) : defaultConfig;\r\n\r\n        std::string configPath = joinPaths(path, Luau::kConfigName);\r\n\r\n        if (std::optional<std::string> contents = readFile(configPath)) {\r\n            std::optional<std::string> error = Luau::parseConfig(*contents, result);\r\n            if (error)\r\n                configErrors.emplace_back(configPath, *error);\r\n        }\r\n\r\n        return configCache[path] = result;\r\n    }\r\n};\r\n\r\n/*\r\n\r\n    Compiling Lua Files\r\n\r\n */\r\n\r\nstatic bool compileFile(const std::string& name) {\r\n    std::optional<std::string> source = readFile(name);\r\n    if (!source) {\r\n        fprintf(stderr, \"Error opening %s\\n\", name.c_str());\r\n        return false;\r\n    }\r\n\r\n    try {\r\n        Luau::BytecodeBuilder bcb;\r\n        Luau::compileOrThrow(bcb, *source, copts());\r\n        writeFile(name+\".bin\", bcb.getBytecode().data(), 1, bcb.getBytecode().size());\r\n\r\n        return true;\r\n    }\r\n    catch (Luau::ParseErrors &e) {\r\n        for (auto &error: e.getErrors())\r\n            reportError(name.c_str(), error);\r\n        return false;\r\n    }\r\n    catch (Luau::CompileError &e) {\r\n        reportError(name.c_str(), e);\r\n        return false;\r\n    }\r\n}\r\n\r\nextern bool CompileFile (char *file_path) {\r\n\r\n    // I know u will hate this, but I do not have time to change function getSourceFiles.\r\n    char * _f[] = {file_path};\r\n    const std::vector<std::string> files = getSourceFiles(2, _f);\r\n\r\n    if (files.empty()) {\r\n        std::cout << \"fatal error: no source files given\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    /*\r\n\r\n        Command line args\r\n\r\n     */\r\n\r\n    ReportFormat format = ReportFormat::Default;\r\n    Luau::Mode mode = Luau::Mode::Nonstrict;\r\n    bool annotate = false;\r\n\r\n    /*\r\n\r\n        Script Analysis\r\n\r\n        Checks and verifies the scripts before\r\n        sending for compilation.\r\n\r\n        Performs all sorts of advance type analysis'\r\n\r\n     */\r\n\r\n    std::cout << \"Starting Script Analysis...\" << std::endl;\r\n    {\r\n\r\n        Luau::FrontendOptions frontendOptions;\r\n        frontendOptions.retainFullTypeGraphs = annotate;\r\n\r\n        CliFileResolver fileResolver;\r\n        CliConfigResolver configResolver(mode);\r\n        Luau::Frontend frontend(&fileResolver, &configResolver, frontendOptions);\r\n\r\n        Luau::registerBuiltinTypes(frontend.typeChecker);\r\n        Luau::freeze(frontend.typeChecker.globalTypes);\r\n\r\n        int failed = 0;\r\n\r\n        for (const std::string &path: files) {\r\n            int f = analyzeFile(frontend, path.c_str(), format, annotate);\r\n            if (f)\r\n                std::cout << \"Analyzed \" << path << \" [OK]\\n\";\r\n            else\r\n                fprintf(stderr, \"Analyzed %s [FAILED]\\n\", path.c_str());\r\n            failed += !f;\r\n        }\r\n\r\n        if (!configResolver.configErrors.empty()) {\r\n            failed += int(configResolver.configErrors.size());\r\n\r\n            for (const auto &pair: configResolver.configErrors)\r\n                fprintf(stderr, \"%s: %s\\n\", pair.first.c_str(), pair.second.c_str());\r\n        }\r\n\r\n        if (failed) {\r\n            fprintf(stderr, \"Compilation terminated.  %i files failed script analysis.\", failed);\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    /*\r\n\r\n        Now compiling scripts\r\n\r\n     */\r\n\r\n    std::cout << \"Analyzed files\\nStarting Script Compilation...\" << std::endl;\r\n\r\n    {\r\n\r\n        int failed = 0;\r\n\r\n        for (const std::string &path: files)\r\n            failed += !compileFile(path);\r\n\r\n        if (failed) {\r\n            fprintf(stderr, \"Compilation Terminated.\");\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n    std::cout << \"Compilation Successful.\" << std::endl;\r\n    return true;\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SereneCompiler/SereneCompiler.cpp b/SereneCompiler/SereneCompiler.cpp
--- a/SereneCompiler/SereneCompiler.cpp	(revision c2f6a640c68f3403fa7a1feaab58752f60d4285e)
+++ b/SereneCompiler/SereneCompiler.cpp	(date 1662642766785)
@@ -291,6 +291,11 @@
         return false;
     }
 }
+/*
+
+    CompileFile
+
+*/
 
 extern bool CompileFile (char *file_path) {
 
Index: SereneCompiler/SereneCompiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//\r\n// Created by manna on 8/1/2022.\r\n//\r\n\r\n#ifndef LUAU_SERENECOMPILER_H\r\n#define LUAU_SERENECOMPILER_H\r\n\r\nextern bool CompileFile(char *file_path);\r\n\r\n#endif //LUAU_SERENECOMPILER_H\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SereneCompiler/SereneCompiler.h b/SereneCompiler/SereneCompiler.h
--- a/SereneCompiler/SereneCompiler.h	(revision c2f6a640c68f3403fa7a1feaab58752f60d4285e)
+++ b/SereneCompiler/SereneCompiler.h	(date 1662642766875)
@@ -1,7 +1,10 @@
-//
-// Created by manna on 8/1/2022.
-//
+/*
+
+    Serene Compiler
 
+
+
+*/
 #ifndef LUAU_SERENECOMPILER_H
 #define LUAU_SERENECOMPILER_H
 
Index: SereneCompiler/FileUtils.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// This file is part of the Luau programming language and is licensed under MIT License; see LICENSE.txt for details\r\n#include \"FileUtils.h\"\r\n\r\n#include \"Luau/Common.h\"\r\n\r\n#ifdef _WIN32\r\n#ifndef WIN32_LEAN_AND_MEAN\r\n#define WIN32_LEAN_AND_MEAN\r\n#endif\r\n#ifndef NOMINMAX\r\n#define NOMINMAX\r\n#endif\r\n#include <Windows.h>\r\n#else\r\n#include <dirent.h>\r\n#include <fcntl.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#endif\r\n\r\n#include <string.h>\r\n\r\n#ifdef _WIN32\r\nstatic std::wstring fromUtf8(const std::string& path)\r\n{\r\n    size_t result = MultiByteToWideChar(CP_UTF8, 0, path.data(), int(path.size()), nullptr, 0);\r\n    LUAU_ASSERT(result);\r\n\r\n    std::wstring buf(result, L'\\0');\r\n    MultiByteToWideChar(CP_UTF8, 0, path.data(), int(path.size()), &buf[0], int(buf.size()));\r\n\r\n    return buf;\r\n}\r\n\r\nstatic std::string toUtf8(const std::wstring& path)\r\n{\r\n    size_t result = WideCharToMultiByte(CP_UTF8, 0, path.data(), int(path.size()), nullptr, 0, nullptr, nullptr);\r\n    LUAU_ASSERT(result);\r\n\r\n    std::string buf(result, '\\0');\r\n    WideCharToMultiByte(CP_UTF8, 0, path.data(), int(path.size()), &buf[0], int(buf.size()), nullptr, nullptr);\r\n\r\n    return buf;\r\n}\r\n#endif\r\n\r\nstd::optional<std::string> readFile(const std::string& name)\r\n{\r\n#ifdef _WIN32\r\n    FILE* file = _wfopen(fromUtf8(name).c_str(), L\"rb\");\r\n#else\r\n    FILE* file = fopen(name.c_str(), \"rb\");\r\n#endif\r\n\r\n    if (!file)\r\n        return std::nullopt;\r\n\r\n    fseek(file, 0, SEEK_END);\r\n    long length = ftell(file);\r\n    if (length < 0)\r\n    {\r\n        fclose(file);\r\n        return std::nullopt;\r\n    }\r\n    fseek(file, 0, SEEK_SET);\r\n\r\n    std::string result(length, 0);\r\n\r\n    size_t read = fread(result.data(), 1, length, file);\r\n    fclose(file);\r\n\r\n    if (read != size_t(length))\r\n        return std::nullopt;\r\n\r\n    // Skip first line if it's a shebang\r\n    if (length > 2 && result[0] == '#' && result[1] == '!')\r\n        result.erase(0, result.find('\\n'));\r\n\r\n    return result;\r\n}\r\n\r\n\r\nbool writeFile(const std::string &name,const void *str,int size,unsigned long long count) {\r\n#ifdef _WIN32\r\n    FILE *file = _wfopen(fromUtf8(name).c_str(), L\"wb\");\r\n#else\r\n    FILE* file = fopen(name.c_str(), \"wb\");\r\n#endif\r\n\r\n    if (!file)\r\n        return false;\r\n\r\n    fwrite(str,size,count,file);\r\n    fclose(file);\r\n\r\n    return true;\r\n}\r\n\r\n\r\nstd::optional<std::string> readStdin()\r\n{\r\n    std::string result;\r\n    char buffer[4096] = {};\r\n\r\n    while (fgets(buffer, sizeof(buffer), stdin) != nullptr)\r\n        result.append(buffer);\r\n\r\n    // If eof was not reached for stdin, then a read error occurred\r\n    if (!feof(stdin))\r\n        return std::nullopt;\r\n\r\n    return result;\r\n}\r\n\r\ntemplate<typename Ch>\r\nstatic void joinPaths(std::basic_string<Ch>& str, const Ch* lhs, const Ch* rhs)\r\n{\r\n    str = lhs;\r\n    if (!str.empty() && str.back() != '/' && str.back() != '\\\\' && *rhs != '/' && *rhs != '\\\\')\r\n        str += '/';\r\n    str += rhs;\r\n}\r\n\r\n#ifdef _WIN32\r\nstatic bool traverseDirectoryRec(const std::wstring& path, const std::function<void(const std::string& name)>& callback)\r\n{\r\n    std::wstring query = path + std::wstring(L\"/*\");\r\n\r\n    WIN32_FIND_DATAW data;\r\n    HANDLE h = FindFirstFileW(query.c_str(), &data);\r\n\r\n    if (h == INVALID_HANDLE_VALUE)\r\n        return false;\r\n\r\n    std::wstring buf;\r\n\r\n    do\r\n    {\r\n        if (wcscmp(data.cFileName, L\".\") != 0 && wcscmp(data.cFileName, L\"..\") != 0)\r\n        {\r\n            joinPaths(buf, path.c_str(), data.cFileName);\r\n\r\n            if (data.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)\r\n            {\r\n                // Skip reparse points to avoid handling cycles\r\n            }\r\n            else if (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\r\n            {\r\n                traverseDirectoryRec(buf, callback);\r\n            }\r\n            else\r\n            {\r\n                callback(toUtf8(buf));\r\n            }\r\n        }\r\n    } while (FindNextFileW(h, &data));\r\n\r\n    FindClose(h);\r\n\r\n    return true;\r\n}\r\n\r\nbool traverseDirectory(const std::string& path, const std::function<void(const std::string& name)>& callback)\r\n{\r\n    return traverseDirectoryRec(fromUtf8(path), callback);\r\n}\r\n#else\r\nstatic bool traverseDirectoryRec(const std::string& path, const std::function<void(const std::string& name)>& callback)\r\n{\r\n    int fd = open(path.c_str(), O_DIRECTORY);\r\n    DIR* dir = fdopendir(fd);\r\n\r\n    if (!dir)\r\n        return false;\r\n\r\n    std::string buf;\r\n\r\n    while (dirent* entry = readdir(dir))\r\n    {\r\n        const dirent& data = *entry;\r\n\r\n        if (strcmp(data.d_name, \".\") != 0 && strcmp(data.d_name, \"..\") != 0)\r\n        {\r\n            joinPaths(buf, path.c_str(), data.d_name);\r\n\r\n            int type = data.d_type;\r\n            int mode = -1;\r\n\r\n            // we need to stat DT_UNKNOWN to be able to tell the type\r\n            if (type == DT_UNKNOWN)\r\n            {\r\n                struct stat st = {};\r\n#ifdef _ATFILE_SOURCE\r\n                fstatat(fd, data.d_name, &st, 0);\r\n#else\r\n                lstat(buf.c_str(), &st);\r\n#endif\r\n\r\n                mode = st.st_mode;\r\n            }\r\n\r\n            if (type == DT_DIR || mode == S_IFDIR)\r\n            {\r\n                traverseDirectoryRec(buf, callback);\r\n            }\r\n            else if (type == DT_REG || mode == S_IFREG)\r\n            {\r\n                callback(buf);\r\n            }\r\n            else if (type == DT_LNK || mode == S_IFLNK)\r\n            {\r\n                // Skip symbolic links to avoid handling cycles\r\n            }\r\n        }\r\n    }\r\n\r\n    closedir(dir);\r\n\r\n    return true;\r\n}\r\n\r\nbool traverseDirectory(const std::string& path, const std::function<void(const std::string& name)>& callback)\r\n{\r\n    return traverseDirectoryRec(path, callback);\r\n}\r\n#endif\r\n\r\nbool isDirectory(const std::string& path)\r\n{\r\n#ifdef _WIN32\r\n    DWORD fileAttributes = GetFileAttributesW(fromUtf8(path).c_str());\r\n    if (fileAttributes == INVALID_FILE_ATTRIBUTES)\r\n        return false;\r\n    return (fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;\r\n#else\r\n    struct stat st = {};\r\n    lstat(path.c_str(), &st);\r\n    return (st.st_mode & S_IFMT) == S_IFDIR;\r\n#endif\r\n}\r\n\r\nstd::string joinPaths(const std::string& lhs, const std::string& rhs)\r\n{\r\n    std::string result = lhs;\r\n    if (!result.empty() && result.back() != '/' && result.back() != '\\\\')\r\n        result += '/';\r\n    result += rhs;\r\n    return result;\r\n}\r\n\r\nstd::optional<std::string> getParentPath(const std::string& path)\r\n{\r\n    if (path == \"\" || path == \".\" || path == \"/\")\r\n        return std::nullopt;\r\n\r\n#ifdef _WIN32\r\n    if (path.size() == 2 && path.back() == ':')\r\n        return std::nullopt;\r\n#endif\r\n\r\n    size_t slash = path.find_last_of(\"\\\\/\", path.size() - 1);\r\n\r\n    if (slash == 0)\r\n        return \"/\";\r\n\r\n    if (slash != std::string::npos)\r\n        return path.substr(0, slash);\r\n\r\n    return \"\";\r\n}\r\n\r\nstatic std::string getExtension(const std::string& path)\r\n{\r\n    size_t dot = path.find_last_of(\".\\\\/\");\r\n\r\n    if (dot == std::string::npos || path[dot] != '.')\r\n        return \"\";\r\n\r\n    return path.substr(dot);\r\n}\r\n\r\nstd::vector<std::string> getSourceFiles(int argc, char** argv)\r\n{\r\n    std::vector<std::string> files;\r\n\r\n    for (int i = 1; i < argc; ++i)\r\n    {\r\n        // Treat '-' as a special file whose source is read from stdin\r\n        // All other arguments that start with '-' are skipped\r\n        if (argv[i][0] == '-' && argv[i][1] != '\\0')\r\n            continue;\r\n\r\n        if (isDirectory(argv[i]))\r\n        {\r\n            traverseDirectory(argv[i], [&](const std::string& name) {\r\n                std::string ext = getExtension(name);\r\n\r\n                if (ext == \".lua\" || ext == \".luau\")\r\n                    files.push_back(name);\r\n            });\r\n        }\r\n        else\r\n        {\r\n            files.push_back(argv[i]);\r\n        }\r\n    }\r\n\r\n    return files;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/SereneCompiler/FileUtils.cpp b/SereneCompiler/FileUtils.cpp
--- a/SereneCompiler/FileUtils.cpp	(revision c2f6a640c68f3403fa7a1feaab58752f60d4285e)
+++ b/SereneCompiler/FileUtils.cpp	(date 1662642766800)
@@ -301,7 +301,7 @@
         }
         else
         {
-            files.push_back(argv[i]);
+            files.emplace_back(argv[i]);
         }
     }
 
